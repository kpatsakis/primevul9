void t_cpp_generator::generate_service_async_skeleton(t_service* tservice) {
  string svcname = tservice->get_name();

  // Service implementation file includes
  string f_skeleton_name = get_out_dir() + svcname + "_async_server.skeleton.cpp";

  string ns = namespace_prefix(tservice->get_program()->get_namespace("cpp"));

  ofstream f_skeleton;
  f_skeleton.open(f_skeleton_name.c_str());
  f_skeleton << "// This autogenerated skeleton file illustrates one way to adapt a synchronous"
             << endl << "// interface into an asynchronous interface. You should copy it to another"
             << endl
             << "// filename to avoid overwriting it and rewrite as asynchronous any functions"
             << endl << "// that would otherwise introduce unwanted latency." << endl << endl
             << "#include \"" << get_include_prefix(*get_program()) << svcname << ".h\"" << endl
             << "#include <thrift/protocol/TBinaryProtocol.h>" << endl << endl
             << "using namespace ::apache::thrift;" << endl
             << "using namespace ::apache::thrift::protocol;" << endl
             << "using namespace ::apache::thrift::transport;" << endl
             << "using namespace ::apache::thrift::async;" << endl << endl
             << "using boost::shared_ptr;" << endl << endl;

  // the following code would not compile:
  // using namespace ;
  // using namespace ::;
  if ((!ns.empty()) && (ns.compare(" ::") != 0)) {
    f_skeleton << "using namespace " << string(ns, 0, ns.size() - 2) << ";" << endl << endl;
  }

  f_skeleton << "class " << svcname << "AsyncHandler : "
             << "public " << svcname << "CobSvIf {" << endl << " public:" << endl;
  indent_up();
  f_skeleton << indent() << svcname << "AsyncHandler() {" << endl << indent()
             << "  syncHandler_ = std::auto_ptr<" << svcname << "Handler>(new " << svcname
             << "Handler);" << endl << indent() << "  // Your initialization goes here" << endl
             << indent() << "}" << endl;
  f_skeleton << indent() << "virtual ~" << service_name_ << "AsyncHandler();" << endl;

  vector<t_function*> functions = tservice->get_functions();
  vector<t_function*>::iterator f_iter;
  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
    f_skeleton << endl << indent() << function_signature(*f_iter, "CobSv", "", true) << " {"
               << endl;
    indent_up();

    t_type* returntype = (*f_iter)->get_returntype();
    t_field returnfield(returntype, "_return");

    string target = returntype->is_void() ? "" : "_return";
    if (!returntype->is_void()) {
      f_skeleton << indent() << declare_field(&returnfield, true) << endl;
    }
    generate_function_call(f_skeleton, *f_iter, target, "syncHandler_", "");
    f_skeleton << indent() << "return cob(" << target << ");" << endl;

    scope_down(f_skeleton);
  }
  f_skeleton << endl << " protected:" << endl << indent() << "std::auto_ptr<" << svcname
             << "Handler> syncHandler_;" << endl;
  indent_down();
  f_skeleton << "};" << endl << endl;
}