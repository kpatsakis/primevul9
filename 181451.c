bool TestMersenne()
{
	std::cout << "\nTesting Mersenne Twister...\n\n";

	static const unsigned int ENTROPY_SIZE = 32;
	bool pass = true, fail = false;

	// First 10; http://create.stephan-brumme.com/mersenne-twister/
	word32 result[10], expected[10] = {0xD091BB5C, 0x22AE9EF6,
		0xE7E1FAEE, 0xD5C31F79, 0x2082352C, 0xF807B7DF, 0xE9D30005,
		0x3895AFE1, 0xA1E24BBA, 0x4EE4092B};

	MT19937ar prng;
	prng.GenerateBlock(reinterpret_cast<byte*>(result), sizeof(result));
	fail = (0 != ::memcmp(result, expected, sizeof(expected)));

	pass &= !fail;
	if (fail)
		std::cout << "FAILED:";
	else
		std::cout << "passed:";
	std::cout << "  Expected sequence from MT19937ar (2002 version)\n";

	MeterFilter meter(new Redirector(TheBitBucket()));
	RandomNumberSource test(prng, 100000, true, new Deflator(new Redirector(meter)));

	fail = false;
	if (meter.GetTotalBytes() < 100000)
		fail = true;

	pass &= !fail;
	if (fail)
		std::cout << "FAILED:";
	else
		std::cout << "passed:";
	std::cout << "  100000 generated bytes compressed to " << meter.GetTotalBytes() << " bytes by DEFLATE\n";

	try
	{
		fail = false;
		prng.DiscardBytes(100000);
	}
	catch (const Exception&)
	{
		fail = true;
	}

	pass &= !fail;
	if (fail)
		std::cout << "FAILED:";
	else
		std::cout << "passed:";
	std::cout << "  discarded 10000 bytes\n";

	try
	{
		fail = false;
		if(prng.CanIncorporateEntropy())
		{
			SecByteBlock entropy(ENTROPY_SIZE);
			GlobalRNG().GenerateBlock(entropy, entropy.SizeInBytes());

			prng.IncorporateEntropy(entropy, entropy.SizeInBytes());
			prng.IncorporateEntropy(entropy, entropy.SizeInBytes());
			prng.IncorporateEntropy(entropy, entropy.SizeInBytes());
			prng.IncorporateEntropy(entropy, entropy.SizeInBytes());
		}
	}
	catch (const Exception& /*ex*/)
	{
		fail = true;
	}

	pass &= !fail;
	if (fail)
		std::cout << "FAILED:";
	else
		std::cout << "passed:";
	std::cout << "  IncorporateEntropy with " << 4*ENTROPY_SIZE << " bytes\n";

	try
	{
		// Miscellaneous for code coverage
		(void)prng.AlgorithmName();
		word32 temp = prng.GenerateWord32();
		temp = prng.GenerateWord32((temp & 0xff), 0xffffffff - (temp & 0xff));
		prng.GenerateBlock(reinterpret_cast<byte*>(&result[0]), 4);
		prng.GenerateBlock(reinterpret_cast<byte*>(&result[0]), 3);
		prng.GenerateBlock(reinterpret_cast<byte*>(&result[0]), 2);
		prng.GenerateBlock(reinterpret_cast<byte*>(&result[0]), 1);
		prng.GenerateBlock(reinterpret_cast<byte*>(&result[0]), 0);
		fail = false;
	}
	catch (const Exception&)
	{
		fail = true;
	}

	pass &= !fail;
	if (fail)
		std::cout << "FAILED:";
	else
		std::cout << "passed:";
	std::cout << "  GenerateWord32 and Crop\n";

	std::cout.flush();
	return pass;
}