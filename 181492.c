bool TestRDRAND()
{
	std::cout << "\nTesting RDRAND generator...\n\n";

	bool pass = true, fail = false;
	member_ptr<RandomNumberGenerator> rng;

	try {rng.reset(new RDRAND);}
	catch (const RDRAND_Err &) {}
	if (rng.get())
	{
		RDRAND& rdrand = dynamic_cast<RDRAND&>(*rng.get());
		static const unsigned int SIZE = 10000;

		MeterFilter meter(new Redirector(TheBitBucket()));
		Deflator deflator(new Redirector(meter));
		MaurerRandomnessTest maurer;

		ChannelSwitch chsw;
		chsw.AddDefaultRoute(deflator);
		chsw.AddDefaultRoute(maurer);

		RandomNumberSource rns(rdrand, SIZE, true, new Redirector(chsw));
		deflator.Flush(true);

		CRYPTOPP_ASSERT(0 == maurer.BytesNeeded());
		const double mv = maurer.GetTestValue();
		if (mv < 0.98f)
			fail = true;

		// Coverity finding, also see http://stackoverflow.com/a/34509163/608639.
		StreamState ss(std::cout);
		std::cout << std::setiosflags(std::ios::fixed) << std::setprecision(6);

		pass &= !fail;
		if (fail)
			std::cout << "FAILED:";
		else
			std::cout << "passed:";
		std::cout << "  Maurer Randomness Test returned value " << mv << "\n";

		fail = false;
		if (meter.GetTotalBytes() < SIZE)
			fail = true;

		pass &= !fail;
		if (fail)
			std::cout << "FAILED:";
		else
			std::cout << "passed:";
		std::cout << "  " << SIZE << " generated bytes compressed to " << meter.GetTotalBytes() << " bytes by DEFLATE\n";

		try
		{
			fail = false;
			rdrand.DiscardBytes(SIZE);
		}
		catch (const Exception&)
		{
			fail = true;
		}

		pass &= !fail;
		if (fail)
			std::cout << "FAILED:";
		else
			std::cout << "passed:";
		std::cout << "  discarded " << SIZE << " bytes\n";

		try
		{
			// Miscellaneous for code coverage
			(void)rdrand.AlgorithmName();
			(void)rdrand.CanIncorporateEntropy();
			rdrand.IncorporateEntropy(NULLPTR, 0);

			word32 result = rdrand.GenerateWord32();
			result = rdrand.GenerateWord32((result & 0xff), 0xffffffff - (result & 0xff));
			rdrand.GenerateBlock(reinterpret_cast<byte*>(&result), 4);
			rdrand.GenerateBlock(reinterpret_cast<byte*>(&result), 3);
			rdrand.GenerateBlock(reinterpret_cast<byte*>(&result), 2);
			rdrand.GenerateBlock(reinterpret_cast<byte*>(&result), 1);
			fail = false;
		}
		catch (const Exception&)
		{
			fail = true;
		}

		pass &= !fail;
		if (fail)
			std::cout << "FAILED:";
		else
			std::cout << "passed:";
		std::cout << "  GenerateWord32 and Crop\n";
	}
	else
		std::cout << "RDRAND generator not available, skipping test.\n";

	std::cout.flush();
	return pass;
}