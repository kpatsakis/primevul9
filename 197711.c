add_text_delta_move(gx_device_pdf *pdev, const gs_matrix *pmat)
{
    pdf_text_state_t *const pts = pdev->text->text_state;

    if (matrix_is_compatible(pmat, &pts->in.matrix)) {
        double dx = pmat->tx - pts->in.matrix.tx,
            dy = pmat->ty - pts->in.matrix.ty;
        gs_point dist;
        double dw, dnotw, tdw;
        int code;

        code = set_text_distance(&dist, dx, dy, pmat);
        if (code < 0)
            return code;
        if (pts->wmode)
            dw = dist.y, dnotw = dist.x;
        else
            dw = dist.x, dnotw = dist.y;
        tdw = dw * -1000.0 / pts->in.size;

        /* can_use_TJ is normally true, it is false only when we get a
         * x/y/xyshow, and the width != real_width. In this case we cannot
         * be certain of exactly how we got there. If its a PDF file with
         * a /Widths override, and the operation is an x/y/xyshow (which
         * will happen if the FontMatrix is nither horizontal not vertical)
         * then we don't want to use a TJ as that will apply the Width once
         * for the xhow and once for the Width override. Otherwise, we do
         * want to use TJ as it makes for smaller files.
         */
        if (pts->can_use_TJ && dnotw == 0 && pts->buffer.count_chars > 0 &&
            /*
             * Acrobat Reader limits the magnitude of user-space
             * coordinates.  Also, AR apparently doesn't handle large
             * positive movement values (negative X displacements), even
             * though the PDF Reference says this bug was fixed in AR3.
             *
             * Old revisions used the upper threshold 1000 for tdw,
             * but it appears too big when a font sets a too big
             * character width in setcachedevice. Particularly this happens
             * with a Type 3 font generated by Aldus Freehand 4.0
             * to represent a texture - see bug #687051.
             * The problem is that when the Widths is multiplied
             * to the font size, the viewer represents the result
             * with insufficient fraction bits to represent the precise width.
             * We work around that problem here restricting tdw
             * with a smaller threshold 990. Our intention is to
             * disable Tj when the real glyph width appears smaller
             * than 1% of the width specified in setcachedevice.
             * A Td instruction will be generated instead.
             * Note that the value 990 is arbitrary and may need a
             * further adjustment.
             */
             /* Revised the above. It seems unreasonable to use a fixed
              * value which is not based on the point size, when the problem is
              * caused by a large point size being multiplied by the width. The
              * original fix also caused bitmap fonts (from PCL and other sources)
              * to fail to use kerning, as these fonts are scaled to 1 point and
              * therefore use large kerning values. Instead we check the kerned value
              * multiplied by the point size of the font.
              */
            (tdw >= -MAX_USER_COORD && (tdw * pts->in.size) < MAX_USER_COORD)
            ) {
            /* Use TJ. */
            int code = append_text_move(pts, tdw);

            if (code >= 0)
                goto finish;
        }
    }
    return -1;
 finish:
    pts->in.matrix = *pmat;
    return 0;
}